/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Auto-generated code. Do not edit.

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using Google.GenAI.Serialization;

namespace Google.GenAI.Types {
  /// <summary>
  /// Incremental server update generated by the model in response to client messages.    Content is
  /// generated as quickly as possible, and not in real time. Clients   may choose to buffer and
  /// play it out in real time.
  /// </summary>

  public record LiveServerContent {
    /// <summary>
    /// The content that the model has generated as part of the current conversation with the user.
    /// </summary>
    [JsonPropertyName("modelTurn")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Content ? ModelTurn { get; set; }

    /// <summary>
    /// If true, indicates that the model is done generating. Generation will only start in response
    /// to additional client messages. Can be set alongside `content`, indicating that the `content`
    /// is the last in the turn.
    /// </summary>
    [JsonPropertyName("turnComplete")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool
        ? TurnComplete {
            get; set;
          }

    /// <summary>
    /// If true, indicates that a client message has interrupted current model generation. If the
    /// client is playing out the content in realtime, this is a good signal to stop and empty the
    /// current queue.
    /// </summary>
    [JsonPropertyName("interrupted")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool
        ? Interrupted {
            get; set;
          }

    /// <summary>
    /// Metadata returned to client when grounding is enabled.
    /// </summary>
    [JsonPropertyName("groundingMetadata")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public GroundingMetadata
        ? GroundingMetadata {
            get; set;
          }

    /// <summary>
    /// If true, indicates that the model is done generating. When model is       interrupted while
    /// generating there will be no generation_complete message       in interrupted turn, it will
    /// go through interrupted > turn_complete.       When model assumes realtime playback there
    /// will be delay between       generation_complete and turn_complete that is caused by model
    /// waiting for playback to finish. If true, indicates that the model       has finished
    /// generating all content. This is a signal to the client       that it can stop sending
    /// messages.
    /// </summary>
    [JsonPropertyName("generationComplete")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool
        ? GenerationComplete {
            get; set;
          }

    /// <summary>
    /// Input transcription. The transcription is independent to the model       turn which means it
    /// doesn’t imply any ordering between transcription and       model turn.
    /// </summary>
    [JsonPropertyName("inputTranscription")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Transcription
        ? InputTranscription {
            get; set;
          }

    /// <summary>
    /// Output transcription. The transcription is independent to the model       turn which means
    /// it doesn’t imply any ordering between transcription and       model turn.
    /// </summary>
    [JsonPropertyName("outputTranscription")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Transcription
        ? OutputTranscription {
            get; set;
          }

    /// <summary>
    /// Metadata related to url context retrieval tool.
    /// </summary>
    [JsonPropertyName("urlContextMetadata")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public UrlContextMetadata
        ? UrlContextMetadata {
            get; set;
          }

    /// <summary>
    /// Reason for the turn is complete.
    /// </summary>
    [JsonPropertyName("turnCompleteReason")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public TurnCompleteReason
        ? TurnCompleteReason {
            get; set;
          }

    /// <summary>
    /// If true, indicates that the model is not generating content because       it is waiting for
    /// more input from the user, e.g. because it expects the       user to continue talking.
    /// </summary>
    [JsonPropertyName("waitingForInput")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool
        ? WaitingForInput {
            get; set;
          }

    /// <summary>
    /// Deserializes a JSON string to a LiveServerContent object.
    /// <param name="jsonString">The JSON string to deserialize.</param>
    /// <param name="options">Optional JsonSerializerOptions.</param>
    /// <returns>The deserialized LiveServerContent object, or null if deserialization
    /// fails.</returns>
    /// </summary>
    public static LiveServerContent
        ? FromJson(string jsonString, JsonSerializerOptions? options = null) {
      try {
        return JsonSerializer.Deserialize<LiveServerContent>(jsonString, options);
      } catch (JsonException e) {
        Console.Error.WriteLine($"Error deserializing JSON: {e.ToString()}");
        return null;
      }
    }
  }
}
